Node: the thing that store the data within the tree . 
	(each circle in the above diagram is a node)
Root Node: the top most node from which all other nodes 
	come from. A is the root node of the tree.
Subtree: Some portion of the entire tree, includes a 
	node (the root of the subtree) and every node that 
	goes downwards from there. A is the root of the 
	entire tree. B is the root of the subtree containing B,D,E and F
Empty trees: A tree with no nodes
Leaf Node: A node with only empty subtrees (no children) 
	Ex. D,E,F,I,J,and G are all leaf nodes
Children: the nodes that is directly 1 link down from 
	a node is that node's child node. 
	Ex. B is the child of A. I is the child of H
Parent the node that is directly 1 link up from a node. 
	Ex. A is parent of B. H is the parent of I
Sibling: All nodes that have the same parent node are siblings 
	Ex. E and F are siblings of D but H is not
Ancestor: All nodes that can be reached by moving only 
	in an upward direction in the tree. 
	Ex. C, A and H are all ancestors of I but G and B are not.
Descendants or Successors of a node are nodes that can be 
	reached by only going down in the tree. 
	Ex. Descendants of C are G,H,I and J
Depth: Distance from root node of tree. Root node is 
	at depth 0. B and C are at depth 1. Nodes at depth 
	2 are D,E,F,G and H. Nodes at depth 3 are I and J
Height: Total number of nodes from root to furthest leaf. 
	Our tree has a height of 4.
Path: Set of branches taken to connect an ancestor of a 
	node to the node. Usually described by the set of 
	nodes encountered along the path.
Binary tree: A binary tree is a tree where every node 
	has 2 subtrees that are also binary trees. The subtrees 
	may be empty. Each node has a left child and a right child. 
	Our tree is NOT a binary tree because B has 3 children.
Preorder Traversal: visit note -> left subtree -> right subtree
Inorder Traversal: 	visit left subtree -> node -> right subtree
Postorder Traversal:visit left subtree -> right subtree -> node
Height Balance: If right side is higher, result + on node that
	contain tree side comparing. If left side is higher, result -
Runtime of Tree: The search time in a perfectly balanced tree 
	is O(log n) as the number of nodes left to consider is 
	effectively halved with each node considered.

For every tree, if value is smaller than root, go left
Binary Tree 
- only describe it shape, does not have any order or specific rules when adding or removing
- with this method, it can skip up to 90% of the node and only follow the path where it should go
- removing 0: just make it nullptr
- removing 1: make the root node point to the child node
- removing 2: find inorder successor (go right one and as far left as possible)
		replace deleting node with that new value

AVL Tree
- perfectly balanced if it is emplty or the difference of node in each subtree is <= 1
- if right tree is taller, root node will be positive, and negative for left tree
- perform rotation if the tree is not balance. 
- Single Rotation: if node are all align (all left or all right), take the middle one and
			put the other 2 in 2 side
- Double Rotation: put the un aligned one to the middle position so that they are aligned
			then follow the procedure for Single Rotation
- Delete is similar with Binary, ensure the tree is still balanced after delete


Red-Black Tree  
- Every node must be either red or black
- Root node cannot be red
- if root node is red, children must be black. 2 red children = 1 red parent
- every path must consist the same number of black node
- new added node are always red
-  

Min Heap
- when removing, select the latest node added, swap with root, then perform swapping
again, starting from the left side down


























